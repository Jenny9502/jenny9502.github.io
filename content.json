{"meta":{"title":"Zyn","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"react web的微信分享-JS-SDK","slug":"web的微信分享-JS-SDK","date":"2018-07-12T08:24:03.000Z","updated":"2018-07-30T10:01:41.134Z","comments":true,"path":"2018/07/12/web的微信分享-JS-SDK/","link":"","permalink":"http://yoursite.com/2018/07/12/web的微信分享-JS-SDK/","excerpt":"","text":"这是小姐姐我在做 web页面 需要在微信端正确分享的文章 何为 “正确” 说法,就是在微信端分享的时候,分享链接所带的小图,文章,链接是自定义的. 开发环境: 脚手架:react-boilerplate 打包工具: webpack 一、了解 微信JS-SDK说明文档web端微信的分享接口说明都在这个文档里,只要你慢慢研究,还是很好理解的. 先别着急着直接看微信分享接口,要一步一步来哦. 二、使用分享接口的步骤1.绑定域名 先登录微信公众平台进入“公众号设置”的“功能设置”里填写“JS接口安全域名”。这个很好设置,本来要 po 步骤图的,但是无奈我不是管理员现在不能进账号 截图给你们分享了.but这一步还是很好操作的,相信大家都能很快做好!! 2.引入JS文件有两种方式引入JS文件 (1) 在需要调用JS接口的页面引入如下JS文件,（支持https）:http://res.wx.qq.com/open/js/jweixin-1.2.0.js(2) 使用 AMD/CMD 标准模块加载方法 : npm install weixin-js-sdk三、代码示例1.创建分享文件 share.js// 微信分享 import wx from &apos;weixin-js-sdk&apos;; import { getWxConfig } from &apos;./service&apos;; //设置不配置分享情况下的 title,描述,小图 const baseTitle = &apos;XXXX&apos;; const baseDesc = &apos;XXXX&apos;; const baseImgUrl = &apos;XXXX&apos;; /** * 分享信息配置 * @param shareMsg 分享信息对象 */ export const shareConfig = (shareMsg) =&gt; { //请求微信分享的固定配置函数,{url: 当前页面地址} 这是封装好的函数请求调用 Promise getWxConfig({ url: shareMsg.url }).then((data) =&gt; { wx.config({ debug: false, appId: data.appid, timestamp: data.timestamp, nonceStr: data.noncestr, signature: data.signature, jsApiList: [&apos;onMenuShareTimeline&apos;, &apos;onMenuShareAppMessage&apos;, &apos;onMenuShareQQ&apos;, &apos;onMenuShareQZone&apos;], }); }); wx.ready(() =&gt; { // 分享到朋友圈 wx.onMenuShareTimeline({ title: shareMsg.title ? `${shareMsg.title}-${baseTitle}` : baseTitle, // 分享标题 link: shareMsg.url, // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致 imgUrl: shareMsg.imgurl || baseImgUrl, // 分享图标 }); // 分享给朋友 wx.onMenuShareAppMessage({ title: shareMsg.title ? `${shareMsg.title}-${baseTitle}` : baseTitle, desc: shareMsg.desc ? `${shareMsg.title}-${baseDesc}` : &apos;&apos;, // 分享描述 link: shareMsg.url, imgUrl: shareMsg.imgurl || baseImgUrl, type: &apos;&apos;, // 分享类型,music、video或link，不填默认为link dataUrl: &apos;&apos;, // 如果type是music或video，则要提供数据链接，默认为空 }); // 分享到QQ wx.onMenuShareQQ({ title: shareMsg.title ? `${shareMsg.title}-${baseTitle}` : baseTitle, desc: shareMsg.desc ? `${shareMsg.title}-${baseDesc}` : &apos;&apos;, // 分享描述 link: shareMsg.url, imgUrl: shareMsg.imgurl || baseImgUrl, }); // 分享到QQ空间 wx.onMenuShareQZone({ title: shareMsg.title ? `${shareMsg.title}-${baseTitle}` : baseTitle, desc: shareMsg.desc ? `${shareMsg.title}-${baseDesc}` : &apos;&apos;, // 分享描述 link: shareMsg.url, imgUrl: shareMsg.imgurl || baseImgUrl, }); }); }; /** * 设置调用微信分享函数 * @param title 标题 * @param desc 描述 * @param img 小图 */ export const setWxShare = (title, desc, img) =&gt; { const url = img &amp;&amp; (img.indexOf(&apos;http&apos;) ? img : `http:${img}`); const shareMsg = { url: location.href.split(&apos;#&apos;)[0], desc, title, imgurl: url, }; shareConfig(shareMsg); }; 2.在需要微信分享的页面调用 setWxShare() 函数就可以了3.后台参数的生成 以上就是前端需要做好的. But,最重要的就是 微信固定配置的 appId, timestamp, nonceStr, signature 这些值得获取.我们这里是通过请求后台直接编辑好把这些值返回给前端. wx.config({ debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。 appId: &apos;&apos;, // 必填，公众号的唯一标识 timestamp: , // 必填，生成签名的时间戳 nonceStr: &apos;&apos;, // 必填，生成签名的随机串 signature: &apos;&apos;,// 必填，签名 jsApiList: [] // 必填，需要使用的JS接口列表 }); (1) appId appId 可以直接登录微信平台 微信公众平台-开发-基本配置 查看 (2) timestamp timestamp 生成签名的时间戳,后台返回的值,和生成签名时的时间戳保持一致. (3) nonceStr nonceStr 生成签名的随机串 后台返回的值,和生成签名时的随机串保持一致. eg: const noncestr1 = () =&gt; { const data = [&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;, &apos;H&apos;, &apos;I&apos;, &apos;J&apos;, &apos;K&apos;, &apos;L&apos;, &apos;M&apos;, &apos;N&apos;, &apos;O&apos;, &apos;P&apos;, &apos;Q&apos;, &apos;R&apos;, &apos;S&apos;, &apos;T&apos;, &apos;U&apos;, &apos;V&apos;, &apos;W&apos;, &apos;X&apos;, &apos;Y&apos;, &apos;Z&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;, &apos;m&apos;, &apos;n&apos;, &apos;o&apos;, &apos;p&apos;, &apos;q&apos;, &apos;r&apos;, &apos;s&apos;, &apos;t&apos;, &apos;u&apos;, &apos;v&apos;, &apos;w&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;]; let str = &apos;&apos;; for (let i = 0; i &lt; 16; i++) { const r = Math.floor(Math.random() * 62); // 取得0-62间的随机数，目的是以此当下标取数组data里的值！ str += data[r]; // 输出20次随机数的同时，让rrr加20次，就是20位的随机字符串了。 } return str; }; (4) signature signature 最重要的也是最难的,可以参考微信的官方文档 附录1-JS-SDK使用权限签名算法生成 signature 还需要了解 jsapi_ticket (是公众号用于调用微信JS接口的临时票据),然而 jsapi_ticket 是通过 access_token 获取的 可以参考 微信的官方文档 生成 jsapi_ticket 的请求链接是: https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET https请求方式: GET其中 APPID, APPSECRET 的值可以在 微信公众平台-开发-基本配置 查看返回值的 access_token 就是需要的值 Tips: 调用接口时，请登录“微信公众平台-开发-基本配置”提前将服务器IP地址添加到 IP白名单 中, 否则将无法调用成功。可以在 微信公众平台-开发-基本配置-IP白名单 配置 步骤1. 按要求拼值 对所有待签名参数按照字段名的ASCII 码从小到大排序（字典序）后，使用URL键值对的格式（即key1=value1&amp;key2=value2…）拼接成字符串string1。微信官方例子: noncestr=Wm3WZYTPz0wzccnW jsapi_ticket=sM4AOVdWfPE4DxkXGEs8VMCPGGVi4C3VM0P37wVUCFvkVAy_90u5h9nbSlYy3-Sl-HhTdfl2fzFy1AOcHKP7qg timestamp=1414587457 url=http://mp.weixin.qq.com?params=value // 需要分享的URL 拼接的 string1 = jsapi_ticket=sM4AOVdWfPE4DxkXGEs8VMCPGGVi4C3VM0P37wVUCFvkVAy_90u5h9nbSlYy3-Sl-HhTdfl2fzFy1AOcHKP7qg&amp;noncestr=Wm3WZYTPz0wzccnW&amp;timestamp=1414587457&amp;url=http://mp.weixin.qq.com?params=value; 步骤2. 对string1进行sha1签名，得到signature：0f9de62fce790f9a083d5c99e95740ceb90c27ed sha1 可以通过 外部下载得到此方法. Tips: 1.签名用的noncestr和timestamp必须与wx.config中的nonceStr和timestamp相同。 2.签名用的url必须是调用JS接口页面的完整URL。 3.出于安全考虑，开发者必须在服务器端实现签名的逻辑。 如出现invalid signature 等错误详见 微信的官方文档附录5-常见错误及解决方法 常见错误及解决办法。","categories":[],"tags":[]},{"title":"使用 git 整理笔记 ","slug":"使用-git-整理笔记","date":"2018-03-10T09:06:49.000Z","updated":"2018-06-23T09:27:29.754Z","comments":true,"path":"2018/03/10/使用-git-整理笔记/","link":"","permalink":"http://yoursite.com/2018/03/10/使用-git-整理笔记/","excerpt":"","text":"记录常用 git 操作克隆远端代码git clone &apos;远端代码地址: Use an SSH key&apos; 分支管理查看当前所有分支 git branch 创建分支 work 为分支名可自定义 git branch work 切换分支 切换到work分支 git checkout work 创建并切换到敢创建的分支 git checkout -b work 删除分支 work git branch -d work 缓存缓存当前未提交的代码 git stash 缓存当前未提交代码并命名为 stashOne git stash save &quot;stashOne&quot; 查看缓存区列表 git stash list 取出缓存区最新的一条缓存代码 (取出的同时在缓存区移除) git stash pop 取出指定列表代码 代码编号(从list查看) git stash apply &quot;代码编号&quot; git 合作开发的基本操作拉取远端代码 拉取最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突git pull 推送代码到远程git push 添加修改的文件到版本库git add 添加所有的修改 git add . 添加指定文件的修改 git add &quot;指定路径&quot; 撤销修改git checkout 撤销所有的修改 git checkout . 撤销指定文件的修改 git checkout &quot;指定路径&quot; 提交上一步 add 的文件git commit -m &quot;此次修改或增加的功能简要说明&quot; 切换分支 切换到work分支git checkout work 查看提交日志git log 查看使用命令日志git reflog 查看工作区文件修改的内容git diff 版本回退HEAD:代表当前版本,HEAD^代表上个版本,HEAD^^上上个版本……HEAD~100…… git reset --hard 版本号 (或者HEAD)","categories":[],"tags":[]},{"title":"使用 redux 的相关笔记整理","slug":"使用-redux-的相关笔记整理","date":"2018-03-10T04:04:57.000Z","updated":"2018-07-06T09:52:39.705Z","comments":true,"path":"2018/03/10/使用-redux-的相关笔记整理/","link":"","permalink":"http://yoursite.com/2018/03/10/使用-redux-的相关笔记整理/","excerpt":"","text":"因为项目用的脚手架是react-boilerplate,只要在创建容器(containers)选择添加redux,则会自动生成 actions.js , constants.js , index.js , reducer.js , saga.js , selectors.js 五个文件. index.js 就不用解释了吧. Constants.js用来定义 type 的 /* * AppConstants * Each action has a corresponding type, which the reducer knows and picks up on. * To avoid weird typos between the reducer and the actions, we save them as * constants here. We prefix them with &apos;yourproject/YourComponent&apos; so we avoid * reducers accidentally picking up actions they shouldn&apos;t. * * Follow this format: * export const YOUR_ACTION_CONSTANT = &apos;yourproject/YourContainer/YOUR_ACTION_CONSTANT&apos;; */ export const LOAD_REPOS = &apos;boilerplate/App/LOAD_REPOS&apos;; export const LOAD_REPOS_SUCCESS = &apos;boilerplate/App/LOAD_REPOS_SUCCESS&apos;; export const LOAD_REPOS_ERROR = &apos;boilerplate/App/LOAD_REPOS_ERROR&apos;; 需要新增 type 时,直接更具上面写法更改就好了,这个 type 就相当于以一个指令,当你需要更改数据时就会发送这样一个 type 信号,然后在action.js, saga.js, reducer.js , 文件就会接收到这个信号,做出相应的操作. reducer.js初始化 state /* * AppReducer * * The reducer takes care of our data. Using actions, we can change our * application state. * To add a new action, add it to the switch statement in the reducer function * * Example: * case YOUR_ACTION_CONSTANT: * return state.set(&apos;yourStateVariable&apos;, true); */ import { fromJS } from &apos;immutable&apos;; import { LOAD_REPOS_SUCCESS, LOAD_REPOS, LOAD_REPOS_ERROR, } from &apos;./constants&apos;; // The initial state of the App const initialState = fromJS({ loading: false, error: false, currentUser: false, userData: { repositories: false, }, }); function appReducer(state = initialState, action) { switch (action.type) { case LOAD_REPOS: return state .set(&apos;loading&apos;, true) .set(&apos;error&apos;, false) .setIn([&apos;userData&apos;, &apos;repositories&apos;], false); case LOAD_REPOS_SUCCESS: return state .setIn([&apos;userData&apos;, &apos;repositories&apos;], action.repos) .set(&apos;loading&apos;, false) .set(&apos;currentUser&apos;, action.username); case LOAD_REPOS_ERROR: return state .set(&apos;error&apos;, action.error) .set(&apos;loading&apos;, false); default: return state; } } export default appReducer; 其中 initialState 就是初始化 参数, appReducer 是对检测到相应的 type 值,进行相应的赋值, 其中的 action.username 是在发送 type 的函数附带的参数值.这个参数会在 actions.js 定义方法的时候定义. //将 值(true) 赋给 初始化的参数(&apos;loading&apos;) .set(&apos;loading&apos;,true) actions.js/* * App Actions * * Actions change things in your application * Since this boilerplate uses a uni-directional data flow, specifically redux, * we have these actions which are the only way your application interacts with * your application state. This guarantees that your state is up to date and nobody * messes it up weirdly somewhere. * * To add a new Action: * 1) Import your constant * 2) Add a function like this: * export function yourAction(var) { * return { type: YOUR_ACTION_CONSTANT, var: var } * } */ import { LOAD_REPOS, LOAD_REPOS_SUCCESS, LOAD_REPOS_ERROR, } from &apos;./constants&apos;; /** * Load the repositories, this action starts the request saga * * @return {object} An action object with a type of LOAD_REPOS */ export function loadRepos() { return { type: LOAD_REPOS, }; } /** * Dispatched when the repositories are loaded by the request saga * * @param {array} repos The repository data * @param {string} username The current username * * @return {object} An action object with a type of LOAD_REPOS_SUCCESS passing the repos */ export function reposLoaded(repos, username) { return { type: LOAD_REPOS_SUCCESS, repos, username, }; } /** * Dispatched when loading the repositories fails * * @param {object} error The error * * @return {object} An action object with a type of LOAD_REPOS_ERROR passing the error */ export function repoLoadingError(error) { return { type: LOAD_REPOS_ERROR, error, }; } actions.js 是告诉机制发生了某个type信号的时候,带了什么参数值,然后回到 reducer.js 判断同一个type 值进行赋值. 其中 loadRepos() ,repoLoadingError(),都没有带其他参数.而我们在reducer.js 里定义接受这些发送过来的type值时,也没有需要接受其他的值.但是 reposLoaded(),这里带了两个参数(repos, username),我们也能在reducer.js 里定义接受这些发送过来的type值时,需要到这两个值,将其赋给 currentUser,[‘userData’, ‘repositories’]. selectors.js/** * The global state selectors */ import { createSelector } from &apos;reselect&apos;; const selectGlobal = (state) =&gt; state.get(&apos;global&apos;); const selectRoute = (state) =&gt; state.get(&apos;route&apos;); const makeSelectCurrentUser = () =&gt; createSelector( selectGlobal, (globalState) =&gt; globalState.get(&apos;currentUser&apos;) ); const makeSelectLoading = () =&gt; createSelector( selectGlobal, (globalState) =&gt; globalState.get(&apos;loading&apos;) ); const makeSelectError = () =&gt; createSelector( selectGlobal, (globalState) =&gt; globalState.get(&apos;error&apos;) ); const makeSelectRepos = () =&gt; createSelector( selectGlobal, (globalState) =&gt; globalState.getIn([&apos;userData&apos;, &apos;repositories&apos;]) ); const makeSelectLocation = () =&gt; createSelector( selectRoute, (routeState) =&gt; routeState.get(&apos;location&apos;).toJS() ); export { selectGlobal, makeSelectCurrentUser, makeSelectLoading, makeSelectError, makeSelectRepos, makeSelectLocation, }; selectors.js 是用来给 index.js 取值的. 在index.js通过props取值. 如下 以上是redux的基本实现,一步一步按定义的来,可以很快上手的. saga.js这个是用来执行异步请求的 /** * Gets the repositories of the user from Github */ import { call, put, select, takeLatest } from &apos;redux-saga/effects&apos;; import { LOAD_REPOS } from &apos;containers/App/constants&apos;; import { reposLoaded, repoLoadingError } from &apos;containers/App/actions&apos;; import request from &apos;utils/request&apos;; import { makeSelectUsername } from &apos;containers/HomePage/selectors&apos;; /** * Github repos request/response handler */ export function* getRepos() { // Select username from store const username = yield select(makeSelectUsername()); const requestURL = `https://api.github.com/users/${username}/repos?type=all&amp;sort=updated`; try { // Call our request helper (see &apos;utils/request&apos;) const repos = yield call(request, requestURL); yield put(reposLoaded(repos, username)); } catch (err) { yield put(repoLoadingError(err)); } } /** * Root saga manages watcher lifecycle */ export default function* githubData() { // Watches for LOAD_REPOS actions and calls getRepos when one comes in. // By using `takeLatest` only the result of the latest API call is applied. // It returns task descriptor (just like fork) so we can continue execution // It will be cancelled automatically on component unmount yield takeLatest(LOAD_REPOS, getRepos); } 其中 yield takeLatest(LOAD_REPOS, getRepos) 就是用来监听 type 值发出的信号的. 当应用发送了 ‘LOAD_REPOS’这个信号时,就会自动的执行 getRepos() 方法. 在getRepos方法中,我们可以看到,当请求完成成功后,会调用 actions.js 里的reposLoaded(repos, username),并把repos, username两个参数值附送过去 index.js###取值 const mapStateToProps = createStructuredSelector({ repos: makeSelectRepos(), username: makeSelectUsername(), loading: makeSelectLoading(), error: makeSelectError(), }); const { repos, username, loading, error} = this.props ; 发送type 其实就是发送actiondispatch(loadRepos()); loadRepos(),在actions.js定义了他所带的type值是: LOAD_REPOS, 所以saga.js 也会因此触发 getRepos.通过getRepos函数会触发reposLoaded,repoLoadingError 的 action. 然后再触发reducer.js 里的赋值,从而反应给selectors.js 而刷新界面. Tips 以我开发这段时间来看哦,尽量就是当前容器用只用当前容器的 actions.js , constants.js , reducer.js , saga.js , selectors.js.除非是app.js 下的 全局值. 如果容器引入其他容器的那些type ,action.很容易造成不必要的错误.特别是用了 react-loadable (按需加载).","categories":[],"tags":[]},{"title":"The Learning styled-components","slug":"styled-components","date":"2018-01-16T09:04:22.000Z","updated":"2018-07-05T02:04:16.830Z","comments":true,"path":"2018/01/16/styled-components/","link":"","permalink":"http://yoursite.com/2018/01/16/styled-components/","excerpt":"","text":"安装1$ npm install --save styled-components 引入12import React from 'react';import styled from 'styled-components'; 使用定义1234const Div = styled.div` height:30px; 如同平时写的CSS一样写属性和属性值`; 使用&lt;Div&gt;..&lt;/Div&gt; Tips1.在定义名字时：const 名字 的名字首字母必须是 大写 才能起作用2.使用a标签做引用时，需要结合react-routerimport {Link} from &apos;react-router&apos; const ALink = styled(Link)` 如同平时写的CSS一样写属性和属性值 `; &lt;ALink to=&apos;&apos;&gt;&lt;/ALink&gt; 其中的 to 要必须存在,就是HTML a标签里的 href 3.hover,action…等样式的编写const Div = styled.div` width:100px; &amp;:hover,&amp;focus,&amp;active{ border：1px solid #000; } `; 4.编辑下级样式const Div = styled.div` width:100px; .active{ border：1px solid #000; } `; 多用在引入了其他组件库时的对组件产生的盒子进行样式改动 5.实现有活动状态的高亮const Div = styled.div` color:${props =&gt; props.active ? &apos;#000&apos; : &apos;#fff&apos;} `; &lt;Div active = {true}&gt;黑色字体&lt;/Div&gt; &lt;Div active = {false}&gt;白色字体&lt;/Div&gt; 中括号里的值可以通过组件里的参数进行判断返回值，控制该Div的字体颜色 6.继承其他已定义样式const Div = styled.div` background: red `; const SpanDiv = styled(Div)` color: #ffffff; `; 这样的 SpanDiv 实际是 背景颜色为红色, 字体颜色为白色 的 div 7.继承多个其他已定义样式const Div = styled.div` background: red `; const Div2 = styled.div` color: #ffffff `; const BigDiv = styled(Div,Div2)` font-size: 20px `; 这样的 BigDiv 实际是 背景颜色为红色,字体颜色为白色,字体大小是20px 的 div 暂时学习到的只有这些，后面学到更多会继续更新","categories":[],"tags":[]},{"title":"Learning-React","slug":"Learnin-React","date":"2018-01-16T08:59:05.000Z","updated":"2018-07-06T06:46:35.497Z","comments":true,"path":"2018/01/16/Learnin-React/","link":"","permalink":"http://yoursite.com/2018/01/16/Learnin-React/","excerpt":"","text":"起步起步步骤网上有很多教程，这里就不多说了。我下面主要是记录在学习react过程中遇到的问题以及解决方法。 个人觉得用react开发非常适合多人开发，便于组件与组件之间的维护，提高开发效率。 组件间传递函数 在父组件定义的函数，在子组件调用 父组件： 123456//定义需要传递的函数parentTest = (msg) =&gt; &#123; console.log(\"msg:\",msg);&#125;//传递函数都子组件&lt;child TabClick=&#123;(msg) =&gt; &#123;this.parentTest(msg)&#125;&#125;&gt;&lt;/child&gt; 子组件: 12//在子组件调用TabClick函数&lt;Test onClick=&#123;(e)=&gt;this.props.TabClick(e)&#125;&gt;&lt;/Test&gt; State赋值1234state=&#123; name: 'zyn', List: [2,4,7]&#125; 只能设置this.setState({‘name’,’hhh’})，不能设置this.setState({‘list[2]’,3}) 更新组件 =&gt; this.setState123456state=&#123; title: 'is old',&#125;this.setState(&#123;title: \"is change\"&#125;);console.log(this.state.title) 其实的控制台打印的是 is old 在没有好好学习前,我会这样写 1234this.setState(&#123;title: \"is change\"&#125;);setTimeOut(function()&#123; console.log(this.state.title);&#125;,0) 在延时器里操作确保得到的值是最新的,但是现在 123this.setState(&#123;title: \"is change\"&#125;,() =&gt; &#123; console.log(this.state.title);&#125;); 可以写一个回调函数直接在后面操作 组件基类 Component 和 PureComponent 的区别 一般我们是通过控制组件的state，props的变化刷新组件。 12345//同一个statestate=&#123; name: 'zyn', List: [2,4,7]&#125; 当设置了this.setState({‘name’,’hhh’})，在Component和PureComponent基类下，组件都会刷新。当更改了list[2]的值，重新给this.setState({‘list’,list})赋值后，在Component下组件会刷新，而在PureComponent下组件不会刷新。所以，在PureComponent基类下，只有state的根值发生变化才会引发组件的变化。 约束组件和非约束组件报错约束组件和非约束组件之一 在Input组件，不使用defaultvalue来控制值时(也就是用value)，需要添加一个onChange事件，即使是空的也要给。 在input的type时，checked={checked}，当这个‘checked’值可能会为空时，记得要checked={checked || ‘’},也要赋值 生命周期ComponentWillReceiveProps 使用这个生命周期的时候需要主要，只要以改变state和prop，组件都会触发刷新，所以需要进行判断是否需要刷新组件。 12345eg: componentWillReceiveProps(nextProps) &#123; if (nextProps.location.search !== this.props.location.search) &#123; this.props.dispatch(loadList()); &#125; key 键 特别注意在数组遍历取值时,返回的元素中必须带上 key 值,这样才能保证你的更改能正确的执行.并且建议 key 的取值 取唯一标识的 id. 更新ing","categories":[],"tags":[]},{"title":"使用hexo的基本操作","slug":"第一次创建hexo文件","date":"2017-12-28T08:26:26.000Z","updated":"2018-06-23T09:57:34.458Z","comments":true,"path":"2017/12/28/第一次创建hexo文件/","link":"","permalink":"http://yoursite.com/2017/12/28/第一次创建hexo文件/","excerpt":"","text":"hexo 基本用法和git代码管理hexo server :启动本地浏览; hexo new post &quot;新建文件名&quot;：新建一篇文章; hexo clean &amp;hexo g :更改了配置文件后，需要更新文件并且重置； hexo generate 生成静态文件 hexo deploy 部署网站 git status //查看有什么改动的代码，这里运营了git来管理代码 git add . //确认添加修改的代码 git commit //commit修改的代码 git push代码到网上的博客(我这里是push 到 origin source); 记录常用Markdown 基本语法的使用段落 直接写 标题在首行插入1到6个‘#’，对应到标题1到6阶 代码块代码行缩进四个空格 分割线在一行中用三个或以上的星号，减号，底线来建立一个分割线，行内不能有其他东西 链接Markdown 支持两种形式的链接语法： 行内式和参考式， 但是不管哪一种， 链接文字都是用 “[方括号]”来标记 插入超链接语法[链接名](URL) 百度 行内式只要在方块括号后面紧接着圆括号并插入网址链接即可，1是有“Title” 的。 1.This is [an example](http://www.baidu.com/ &quot;Title&quot;) inline link 显示如下,注意加title前面需要空格隔开 This is an example inline link 2.[This link](http://www.baidu.com/)has no title attribute 显示如下 This linkhas no title attribute 参考式链接是在链接文字的括号后面在接一个方括号，而在第二个方括号里面填入用以辨识链接的标记，我不常用，不写了 插入图片 插入图片语法 ![图片的替代文字](图片URL &quot;title&quot;) ![somi](http://p1p8cvl3a.bkt.clouddn.com/f.png &quot;somi&quot;) Tips:创建了七牛CDN的网上存储器 – 管理控制台-对象存储-内容管理-上传文件-选择文件后即可使用链接打开图片","categories":[],"tags":[]}]}